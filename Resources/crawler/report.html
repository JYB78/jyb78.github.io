<link rel="stylesheet" href="styles.css">
<h1 id="quest-6">Autonumous-Driving Crawler Final Report</h1>
<p>Cindy Bai, Jess Barry, Zach Carlson</p>
<h2 id="summary">Summary</h2>
<img src="./images/simple.png" alt="screenshot"/> 
<p>Above is a high-level flow chart of our quest 6 implementation. We have four different modes for the crawler: STOP(0), AUTO(1), MANUAL FORWARD(2), MANUAL BACKWARD(3). More detailed flow charts are included in the Sketches and Photos section below.</p>
<p>During our demo, we were able to demonstrate all criteria listed on rubric except for when doing the second turn. (A more detailed list of things we have successfully demonstrated is shown below.) We ended up fixing the error a few minutes after our demo and was in line for a re-do, but unfortunately we did not get to re-do the demo since we had to leave for senior design. So, we asked for a beacon and returned to the demo room later that day and we successfully completed the entire course around BOTH corners. We took a video of our crawler going around the room and that video clip is included in our team video linked below.</p>
<p>Here is a list of things that we have demonstrated working during our demo: - Crawler stop/go in reaction to beacon IR signal - Current split time recorded when seeing a &quot;R&quot; signal from beacon - Most recent split time shown on the Alpha Display on top of Crawler - Drive straight lines along the wall in Auto mode - Go around (first) 90 degree corner without collision in Auto mode - All split times sent to server are recorded into a level database (log also shown on the web client) - Live streaming from webcam visible from web client - Allow both automatic and manual switches between modes - Remote control in manual mode: forward, backward, steering, change speed - Able to automatically decode QR code after driving the crawler to the front of the QR through manual control from web client - Server, web client, and database hosted remotely on RPi</p>
<p>We have alsoe implemented some functionalities that are not required by the objective criteria of the quest: - Can go both forward AND backward when in Manual mode (mode 3 or 4) - PID wheelSpeed control implemented in BOTH Manual &amp; Auto Mode - User speed control for both moving forward AND backward: 0.1/0.3/0.5 m/sec - Displays total time passed since the first starting green light (1st beacon) on web client - Able to switch between Auto &amp; Manual Mode from web client</p>
<h2 id="solution-design">Solution Design</h2>
<h2 id="server-web-client">Server &amp; Web Client</h2>
<h3 id="server">Server</h3>
<h4 id="task-1-udp-socket-to-esp32">Task 1: UDP Socket to ESP32</h4>
<p>A UDP socket is created to communication with ESP32. Data received will be saved to a file named &quot;data.csv&quot;. This file contains all data transferred from the ESP32 except fo the split time since the split time will be recorded into the levelDB. The &quot;data.csv&quot; file contains: - Side distance - Front distance - Current steering angle - Current wheel speed - Total time (in sec) since the start of the crawler running - Current Mode ** A sample &quot;data.csv file is included inside the code folder&quot;</p>
<h4 id="task-2-host-web-client">Task 2: Host Web Client</h4>
<p>The second task of the server is to host the web client (index.html) and handle different POST requests for corresponding buttons. Once a button action is received by the server, it will let the ESP32 know through the UDP socket created in task 1, and the ESP32 will handle these messages accordingly.</p>
<h4 id="task-3-level-database-for-recording-split-times">Task 3: Level Database for recording split times</h4>
<p>The last task of the server is to store the split time received into the levelDB. We parse and look at each message sent by the ESP to the server, and if the message contains the current split time (&quot;curSplit&quot;), it will be stored into the levelDB. Additionally, we confirms that the new split time is recorded correctly by doing a readDB() which creates a read stream of the database and prints everything store inside the database into the console.</p>
<h3 id="web-client">Web Client</h3>
<img src="./images/web1.png" alt="screenshot" /> 
<p>Here is a screenshot of our web client. It displays everything that we need to know when driving the crawler.</p>
<p>The manual speed control is done with selecting the desired speed and clicking on the enter button next to it. The options we have for the speed are: 0.1, 0.3, and 0.5. We did not set the Manual speed options to be too high since we still want to drive the crawler under control.</p>
<p>The Left and Right buttons works do that it +/- 15 degrees to the current steering angle when clicked once. We do have checking mechanisms to take sure that the angle will not go out of bound (max angle (i.e. max left) = 90 deg &amp;&amp; min angle (i.e. max right) = 0 deg) The center button will bring the steering servo back to center at 45 degree.</p>
<p>Current mode is also displayed on the web client. Options includes: &quot;Stop&quot;, &quot;Automatic&quot;, &quot;Manual Forward&quot;, &quot;Manual Backward&quot;.</p>
<p>The front and side distance readings are also displayed on the web client when in Auto mode.</p>
<p>The web client communicates with the server through POST requests. It uses a POST request to get the content of the data.csv file returned from the server, and parse the data stored and update what's being displayed on the screen. When a button is clicked, it also sends a POST request to the server with the corresponding pathname as argument. The server will then distinguish the different POST requests and send corresponding messages to the ESP32.</p>
<h4 id="webcam-qr-decoding">Webcam &amp; QR Decoding</h4>
<p>The webcam and QR decoding are also implemeted inside the web client (i.e. at browser level). We were using jsQR for QR scanning, and we can simply embed the webcam view using an "img" tag with class=&quot;video&quot;. jsQR works by basically feeding in the current frame of the video every-so-often (using setInterval function), and checks for QR code in the captured frame. We implemented so that it feeds in a new frame every second, and when a QR code is found, it decodes it and print the message onto the web client. The image below is a screenshot of the web client with the QR decoded and displayed: </p>
<img src="./images/QR.png" alt="screenshot"/>
<h2 id="crawler-esp32">Crawler (ESP32)</h2>
<h3 id="wheel-speed-control">Wheel Speed Control</h3>
<p>In general, we are using a few key global variables for overall speed control: speed, setWheel(Speed), mywheelSpeed. We are using PID to control the speed in BOTH Auto and Manual mode. The &quot;dt&quot; (i.e. the timer interval to call PID function) for PID is 1 second, meaning that the global speed variable will be adjusted by comparing the &quot;setWheel&quot; &amp; &quot;mywheelSpeed&quot; variable. Since we have can have our crawler going backwards, we have to make sure that we are add the output of PID to the current speed when going backward (Mode 3: manual_backward) and subtracting when going forward (Mode 1: auto &amp;&amp; Mode 2: manual_forward). #### Auto Mode: The set wheel speed (setWheel) in Auto mode is 0.1 meters per second since we wanted the crawler to move slowly to give time for sensor and IR readings. #### Manual Mode: The set wheel speed (setWheel) in Manual mode is 0.1 by default (both forward and backward). User can change the setWheel to 0.1, 0.3, or 0.5 m/sec through selecting in the dropdown list on the web client.</p>
<h3 id="steering">Steering</h3>
<p>(Max Left: 90 deg, Center/Straight: 45 deg, MAX Right: 0 deg) #### Auto Mode: There are mainly two components that controls the steering in Auto mode: 1. (Right) Side microLIDAR Sensor - Straight</p>
<pre><code>We mounted a microLIDAR on the right side of the crawler. This part is the exact same thing as what we had for Quest 4. The goal is to adjust the steering angle accordingly so that the crawler maintain a certain set distance away from a wall to its right. We have the &quot;setPoint_side&quot; (set-point side distance) to be 75 cm since the beacons will be place 75 cm away from the wall. We are using the &quot;P&quot; part of the PID of adjust the steering angle and the variables &quot;Kp&quot; is 1.</code></pre>
<ol start="2" style="list-style-type: decimal">
<li><p>Front LIDAR Sensor - Turns (90 deg to the left)</p>
<p>This is one of the new feature that we have added for this Quest. Before in Quest 4, we used the front range sensor to detect collisions. Now, we are using it to make turns. The goal is to turn the crawler 90 degrees to the left when it sees a front obstacle such as a wall. We implemented this functionality so that a &quot;turn&quot; flag is switched on when the front sensor gets a reading smaller than 2.5 m. We have a function called &quot;myTurn()&quot; which is responsible for controlling the steering when making turns; this function will maintain max left (90 deg) for 7.5 second and restore regular steering control (with the side microLIDAR sensor). These turning distance and time for turning are obtained through continuous experimenting and calibration.</p></li>
</ol>
<p>Note: both front and side distance readings are sent to the server and displayed on the web client.</p>
<h4 id="manual-mode">Manual Mode:</h4>
<p>In Manual mode, the steering control is pretty straight forward where it will be controlled by user input from the web client. By default, the steering will reset to center (45 deg) when switching from Auto to Manual mode. There are Left and Right buttons on the web client. When a user clicks the Left/Right button, it will +/- 15 deg from the current steering (mySteering) to generate the new steering. The current steering angle is also displayed on the web client in real time. We also have out-of-bound checks so that the user input will always be in the valid range (90 - 0 deg).</p>
<h3 id="traffic-light-beacons-split-time">Traffic Light Beacons &amp; Split Time</h3>
<h4 id="ir-receiver">IR Receiver</h4>
<p>The IR receiver continuously reads in data and iterates through each byte. It checks to see if the the reading contains &quot;R&quot; or &quot;G&quot; and will stop and move forward accordingly. We have global variable called &quot;totalTime&quot;, which is the total time (in sec) passed since the first &quot;G&quot; signal; this variable is also displayed on the web client. This variable is managed by a timer interrupt function through the use of a flag. We designed our IR receiver function so that it stops when it sees a &quot;R&quot; and record the current totalTime as the curSplit (most current split time) since ideally we want to be able to stop at all three beacons on the way. The string format of the new curSplit (&quot;str_split&quot;, converted to string in Alpha Display function) is then send to the server and recorded into the levelDB.</p>
<h4 id="alpha-display">Alpha Display</h4>
<p>The curSplit is split up into two variables representing seconds and minutes, then both are turned into strings using itoa(). The string form of the curSplit is in the formate of &quot;min:sec&quot;, and this string is stored as a global variable called &quot;str_split&quot;; this string is what is send to the server through the UDP socket and store in the database since it is easier to read the time this way. Then based on the values of those strings, the indexes are set depending on the amount of digits each variable has. Once the indexes are assigned, each display buffer value is assigned based on the index into the alphafont table.</p>
<h3 id="timer">Timer</h3>
<p>The timer is used in keeping track of the totalTime and manages the PID function to adjust wheelSpeed as mentioned above. The timer is done with a timer interrupt and a global flag (inside the app_main()).</p>
<h3 id="udp-socket-to-server-rpi">UDP Socket to Server (RPi)</h3>
<p>A UDP socket is created using the IP of the RPi (Port 3333) for the ESP/crawler to communicate with the server hosted on the RPi. We can obtain the IP of the RPi from the router's device list page since all components in this quest are connected to wifi from the group router. #### Sending Messages sent are all in the form of &quot;name,value&quot; with on space. This unified formate makes it easier for the server and web client to parse and understand the messages once they are received. Here is the list of all things (name) sent to the server: - mode - wheelSpeed - totalTime - steering - curSplit - side - front</p>
<h4 id="receiving">Receiving</h4>
<p>In addition, the crawler also needs to be able to receive and react to user control from the web client in Manual mode. When a button is pressed, the server will send corresponding messages to esp. Here is the list of all possible messages and what they mean: - F = Manual Forward Mode - B = Manual Backward Mode - Stop = Stop Mode - A = Auto Mode - L = Left Steering (mySteering += 15) - R = Right Steering (mySteering -= 15) - C = Center Steering (mySteering = 45) - s1/s2/s3 = speed option 1/2/3 (0.1, 0.3, 0,5 m/s)</p>
<h2 id="sketches-and-photos">Sketches and Photos</h2>
<h3 id="detailed-flow-chart">Detailed Flow Chart</h3>
<img src="./images/sketch_server.png" alt="screenshot" /> 
<img src="./images/sketch_crawler.png" alt="screenshot" />
<h3 id="our-crawler">Our Crawler</h3>
    <img src="./images/side.png" alt="screenshot" /> 
    <img src="./images/front.png" alt="screenshot" /> 
    <img src="./images/back.png" alt="screenshot" />


